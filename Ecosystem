```javascript
require("dotenv").config();
const { ethers } = require("ethers");
const { exec } = require("child_process");

/**
 * --- FLASHLIGHT ARBITRAGE CORE ---
 * Implementation of the Statistical Spread Theorem.
 * Full documentation: https://flashlightcoin.com/documentation
 */

// CONFIGURATION FROM ENV (Secure Mode)
const RPC_URL = process.env.RPC_URL; 
const PRIVATE_KEY = process.env.PRIVATE_KEY; 
const CONTRACT_ADDRESS = process.env.CONTRACT_ADDRESS; 

if (!RPC_URL || !PRIVATE_KEY) {
    console.error("Error: Missing .env configuration.");
    process.exit(1);
}

const provider = new ethers.JsonRpcProvider(RPC_URL);
const wallet = new ethers.Wallet(PRIVATE_KEY, provider);

// Official Arbitrum Addresses
const WETH = "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1";
const MULTICALL_ADDR = "0xcA11bde05977b3631167028862bE2a173976CA11";
const UNI_QUOTER = "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6";
const PAN_QUOTER = "0x5E5C9d2303272dEe05a61d10996F7801824A1910"; 

// Minimalistic ABIs for Memory Optimization
const abiQuoter = ["function quoteExactInputSingle(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn, uint160 sqrtPriceLimitX96) external returns (uint256 amountOut)"];
const abiQuoterV2 = ["function quoteExactInputSingle(tuple(address tokenIn, address tokenOut, uint256 amountIn, uint24 fee, uint160 sqrtPriceLimitX96) params) external returns (uint256 amountOut, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)"];
const botAbi = ["function executar(address _emprestimo, address _alvo, uint256 _qtd, uint24 _taxaUni, uint24 _taxaPan, uint256 _lucroMin, bool _startOnUni) external"];
const abiMulticall = ["function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) public view returns (tuple(bool success, bytes returnData)[])"];

const multicall = new ethers.Contract(MULTICALL_ADDR, abiMulticall, provider);
const botContract = new ethers.Contract(CONTRACT_ADDRESS, botAbi, wallet);
const ifaceUni = new ethers.Interface(abiQuoter);
const ifacePan = new ethers.Interface(abiQuoterV2);

// High Liquidity Pairs (Arbitrum)
const ALVOS = [
    { s: "ARB", a: "0x912CE59144191C1204E64559FE8253a0e49E6548" },
    { s: "GMX", a: "0xfc5A1A6EB076a2C7aD06eD22C90d7E710E35ad0a" },
    { s: "WBTC", a: "0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f" },
    { s: "MAGIC", a: "0x539bdE0d7Dbd336b79148AA742883198BBF60342" },
    { s: "PENDLE", a: "0x0c880f6761F1af8d9Aa9C466984b80DAb9a8c9e8" }
];

const FEES = [500, 3000]; // 0.05% and 0.3%
const AMOUNT = ethers.parseEther("1.0"); // Base trade amount

async function scan() {
    try {
        const calls = [];
        const map = [];

        // 1. Packet Construction
        for (const t of ALVOS) {
            for (const fU of FEES) {
                for (const fP of FEES) {
                    calls.push({ 
                        target: UNI_QUOTER, allowFailure: true, 
                        callData: ifaceUni.encodeFunctionData("quoteExactInputSingle", [WETH, t.a, fU, AMOUNT, 0]) 
                    });
                    calls.push({ 
                        target: PAN_QUOTER, allowFailure: true, 
                        callData: ifacePan.encodeFunctionData("quoteExactInputSingle", [{tokenIn: WETH, tokenOut: t.a, amountIn: AMOUNT, fee: fP, sqrtPriceLimitX96: 0}]) 
                    });
                    map.push({ t, fU, fP });
                }
            }
        }

        // 2. Multicall Execution
        const res = await multicall.aggregate3.staticCall(calls);
        
        // 3. In-Memory Analysis
        let maiorSpread = 0;

        for (let i = 0; i < map.length; i++) {
            const rUni = res[i * 2];
            const rPan = res[i * 2 + 1];

            if (!rUni.success || !rPan.success) continue;
            if (rUni.returnData === "0x" || rPan.returnData === "0x") continue;

            const qUni = ifaceUni.decodeFunctionResult("quoteExactInputSingle", rUni.returnData)[0];
            const qPan = ifacePan.decodeFunctionResult("quoteExactInputSingle", rPan.returnData)[0];

            const startUni = qUni > qPan;
            const qtdSaida = startUni ? qUni : qPan;
            const qtdMenor = startUni ? qPan : qUni;

            const spread = Number((qtdSaida * 10000n) / qtdMenor) - 10000; 
            if (spread > maiorSpread) maiorSpread = spread;

            // Trigger based on Spread Theorem (> 0.20%)
            if (spread > 20) { 
                await verificarLucroLiquido(map[i], startUni, qtdSaida, spread);
            }
        }
        process.stdout.write(`\râš¡ Scan: ${ALVOS.length} Pairs | Top Spread: ${(maiorSpread/100).toFixed(2)}%    `);
    } catch (e) { /* Silent fail for network jitters */ }
}

async function verificarLucroLiquido(dados, startUni, qtdRecebida, spreadBruto) {
    try {
        const dexVenda = startUni ? PAN_QUOTER : UNI_QUOTER;
        const ifaceVenda = startUni ? ifacePan : ifaceUni;
        const feeVenda = startUni ? dados.fP : dados.fU;
        const tokenAlvo = dados.t.a;

        let callData;
        if (startUni) {
             callData = ifacePan.encodeFunctionData("quoteExactInputSingle", [{tokenIn: tokenAlvo, tokenOut: WETH, amountIn: qtdRecebida, fee: feeVenda, sqrtPriceLimitX96: 0}]);
        } else {
             callData = ifaceUni.encodeFunctionData("quoteExactInputSingle", [tokenAlvo, WETH, feeVenda, qtdRecebida, 0]);
        }

        const resultado = await provider.call({ to: dexVenda, data: callData });
        const wethVolta = ethers.AbiCoder.defaultAbiCoder().decode(["uint256"], resultado)[0];

        // Cost Calculation: FlashLoan Fee + Gas Estimate
        const custoFlash = (AMOUNT * 5n) / 10000n; 
        const custoGas = ethers.parseEther("0.00035"); 
        
        const lucroFinal = wethVolta - AMOUNT - custoFlash - custoGas;

        if (lucroFinal > 0n) {
            console.log(`\n\nðŸš¨ OPPORTUNITY DETECTED!`);
            console.log(`Pair: ${dados.t.s} | Spread: ${(spreadBruto/100).toFixed(2)}% | Net Profit: ${ethers.formatEther(lucroFinal)} ETH`);
            await executarTrade(dados, startUni);
        }

    } catch (e) { return; }
}

async function executarTrade(dados, startUni) {
    try {
        const feeData = await provider.getFeeData();
        const tx = await botContract.executar(
            WETH, dados.t.a, AMOUNT, dados.fU, dados.fP, 1n, startUni, 
            { gasLimit: 3000000, gasPrice: (feeData.gasPrice * 120n) / 100n }
        );
        console.log(`ðŸš€ TX SENT: ${tx.hash}`);
        await tx.wait();
        console.log("âœ… Execution Confirmed!");
    } catch (e) {
        console.log(`âŒ Reverted: ${e.shortMessage}`);
    }
}

console.log("--- ðŸ† MONITOR V12: OPEN SOURCE EDITION ---");
provider.on("block", () => scan());
